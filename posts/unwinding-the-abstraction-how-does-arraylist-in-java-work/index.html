<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unwinding the Abstraction - How does ArrayList in Java Work? | Random Musings</title><meta name=keywords content><meta name=description content="In this article, we will implement a custom ArrayList from scratch to understand how they work under the hood and what their best and worst use cases are."><meta name=author content><link rel=canonical href=https://www.sayemahmed.com/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/><link crossorigin=anonymous href=/assets/css/stylesheet.75e99ced767a858315a7f7639cf847a348c9cd6d87c9dfe94262be72551a789f.css integrity="sha256-demc7XZ6hYMVp/djnPhHo0jJzW2Hyd/pQmK+clUaeJ8=" rel="preload stylesheet" as=style><link rel=icon href=https://www.sayemahmed.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.sayemahmed.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.sayemahmed.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.sayemahmed.com/apple-touch-icon.png><link rel=mask-icon href=https://www.sayemahmed.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Unwinding the Abstraction - How does ArrayList in Java Work?"><meta property="og:description" content="In this article, we will implement a custom ArrayList from scratch to understand how they work under the hood and what their best and worst use cases are."><meta property="og:type" content="article"><meta property="og:url" content="https://www.sayemahmed.com/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-14T00:00:00+01:00"><meta property="article:modified_time" content="2023-02-14T00:00:00+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Unwinding the Abstraction - How does ArrayList in Java Work?"><meta name=twitter:description content="In this article, we will implement a custom ArrayList from scratch to understand how they work under the hood and what their best and worst use cases are."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.sayemahmed.com/posts/"},{"@type":"ListItem","position":2,"name":"Unwinding the Abstraction - How does ArrayList in Java Work?","item":"https://www.sayemahmed.com/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unwinding the Abstraction - How does ArrayList in Java Work?","name":"Unwinding the Abstraction - How does ArrayList in Java Work?","description":"In this article, we will implement a custom ArrayList from scratch to understand how they work under the hood and what their best and worst use cases are.","keywords":[],"articleBody":"Introduction One of my all-time favourite articles is The Law of Leaky Abstractions by Joel Spolsky. In the article, Joel explains how non-trivial abstractions that make software development more manageable often break. And when they do, we need to understand how they truly work so we can fix them quickly.\nThis is the reason I value learning from first principles. Over the years, I have often applied this learning style to learn more about the tools I use regularly. In this blog post, I will share my learnings on ArrayList, an implementation of List, by building a copy implementation from scratch.\nPlease note that we will not implement a production-grade implementation. Instead, we will focus on implementing the most commonly used list methods to get a feel for how they work and thus understand their use cases better.\nCreating our custom ArrayList class Let’s declare the initial skeleton of the implementation -\npublic class CustomArrayList\u003cE\u003e implements List\u003cE\u003e { private Object[] elements; public CustomArrayList() { elements = new Object[?]; } } The official doc says that List implementations should support holding an arbitrary number of elements. However, we need to specify a size when creating the array. If we specify a large size, then we might waste memory. However, setting a shorter length puts a limitation on our capacity. So what do we do?\nOne way to get around this limitation is to create an array with a small capacity first and then resize it whenever we run out of space. Let’s go ahead and declare a 1-element array -\nelements = new Object[1]; We could also consider passing the size during construction if we have a rough idea of how many elements we will store in this list. This would help us to initialise the array more efficiently as we would need less resizing. We could provide another constructor which would accept an initialCapacity as an argument and use it to initialise the array -\npublic class CustomArrayList\u003cE\u003e implements List\u003cE\u003e { private Object[] elements; public CustomArrayList() { this(1); } public CustomArrayList(int initialCapacity) { elements = new Object[initialCapacity]; } } This is why it’s always better to instantiate ArrayList using capacity if we know it in advance. It avoids unnecessary resizing.\nImplementing methods add(element) We will implement the add method first, which is supposed to append the specified element to the end of this list -\n@Override public boolean add(E element) { // If the insertion is successful, it should return true. // Otherwise, it should return false. // This method should never replace any existing elements. return false; } Before appending the given element in the array, we need to know the next available position. We will define a new instance field, nextIndex, pointing to the next free slot in the array:\npublic class CustomArrayList\u003cE\u003e implements List\u003cE\u003e { private Object[] elements; // Contains 0 by default private int nextIndex; } Once defined, let’s continue our add implementation -\n@Override public boolean add(E element) { elements[nextIndex] = element; nextIndex++; return true; } How do we resize the array when it’s full? One way to do it is to create a new array, copy all the elements from the existing array, and then point elements to this new array:\n@Override public boolean add(E element) { if (nextIndex == elements.length) { Object[] copy = new Object[nextIndex + 1]; for (int i = 0; i \u003c nextIndex; i++) { copy[i] = elements[i]; } elements = copy; } elements[nextIndex] = element; nextIndex++; return true; } What about performance? When we add a 2nd element to our list, we copy the existing element to the new array. On the 3rd add, the loop will copy two elements. Continuing like this, we can say that on N-th add, we will copy (N - 1) elements. To get the total number of copies required for the first N add, we sum them up = 1 + 2 + 3 + ... + (N - 1) = (N - 1) x N / 2.\nAdding the first N elements thus has an amortised time complexity of O(N^2). This means that if we double the size of the elements being added, the total time needed will increase 4-fold. Can we do better?\nThankfully, we can. Instead of increasing the capacity by one, we will double it:\n@Override public boolean add(E element) { if (nextIndex == elements.length) { Object[] copy = new Object[nextIndex * 2]; for (int i = 0; i \u003c nextIndex; i++) { copy[i] = elements[i]; } elements = copy; } elements[nextIndex] = element; nextIndex++; return true; } The amortised time complexity will now reduce to O(N). Like before, the 2nd add will copy one element. But before the 3rd add, our implementation will double the size of the elements array, so the 4th add won’t need to resize it again. The 5th add will again double the capacity and copy the existing 4 elements, but then the 6th, 7th, and 8th calls won’t trigger a resize.\nWe can improve the actual performance even further by acknowledging a property of arrays called Data Locality. Data Locality guarantees that array elements are always stored in consecutive memory locations.\nSo rather than copying one element at a time, how about we copy blocks of memory instead? The System class has one such method, arraycopy, which we can use for this purpose:\n@Override public boolean add(E element) { if (nextIndex == elements.length) { Object[] copy = new Object[nextIndex * 2]; System.arraycopy(elements, 0, copy, 0, nextIndex); elements = copy; } elements[nextIndex] = element; nextIndex++; return true; } We can better understand the performance boost by looking at approximate latency numbers from this chart. As we can see, reading ~1MB of sequential data from main memory takes about ~1 microsecond. On the other hand, a random main memory reference takes about 100 nanoseconds. This shows that reading 10 elements from random memory locations would take roughly the same time as reading 1MB of sequential data.\nMoreover, the CPU will likely have an L1 (and maybe L2) cache. When the OS fetches an array element from the main memory to the L1 cache, it’s likely to prefetch and store the elements at the following indexes, improving the performance even further.\nNotice how we make a conscious trade-off between memory and running time when we double the array. This is fine if memory is available and cheap, which is usually the case. If not, we need a different strategy (i.e., increase the length by 25% or 50%).\nsize() Next, we will implement the size method, which returns the number of elements in the list. The way we used nextIndex in our add method, it will always be equal to the size of the list:\n@Override public int size() { return nextIndex; } remove(index) Next up, the remove method -\n@Override public E remove(int index) { /* * Specification: if the index is out of bound, then throw * IndexOutOfBoundsException. */ if (index \u003c 0 || index \u003e= nextIndex) { throw new IndexOutOfBoundsException( \"index \" + index + \" is out of range\" ); } } If index is the last element in the elements array, we could decrement nextIndex by one so that the next insertion will overwrite the element at index nextIndex - 1:\n@Override public E remove(int index) { /* * Specification: if the index is out of bound, then throw * IndexOutOfBoundsException. */ if (index \u003c 0 || index \u003e= nextIndex) { throw new IndexOutOfBoundsException( \"index \" + index + \" is out of range\" ); } if (index == nextIndex - 1) { nextIndex--; return elements[nextIndex]; } } Unfortunately, this implementation suffers from a memory leak. Let me explain why.\nSuppose we have a list object with 10,000 elements and would like to remove each element one by one from the end without adding any new ones. In that case, nextIndex will keep decreasing, but the references to all these removed objects will still be in the array, preventing garbage collection.\nTo prevent memory leak, we need to explicitly clear the reference by setting it to null:\n@Override public E remove(int index) { /* * Specification: if the index is out of bound, then throw * IndexOutOfBoundsException. */ if (index \u003c 0 || index \u003e= nextIndex) { throw new IndexOutOfBoundsException( \"index \" + index + \" is out of range\" ); } if (index == nextIndex - 1) { nextIndex--; E elementBeingRemoved = (E) elements[index]; elements[nextIndex] = null; return elementBeingRemoved; } } To remove elements from any other position in the array, we can shift all elements starting from index one position to the left and then decrement nextIndex:\n@Override public E remove(int index) { /* * Specification: if the index is out of bound, then throw * IndexOutOfBoundsException. */ if (index \u003c 0 || index \u003e= nextIndex) { throw new IndexOutOfBoundsException( \"index \" + index + \" is out of range\" ); } if (index == nextIndex - 1) { nextIndex--; E elementBeingRemoved = (E) elements[index]; elements[nextIndex] = null; return elementBeingRemoved; } E elementBeingRemoved = (E) elements[index]; nextIndex--; for (int i = index; i \u003c nextIndex; i++) { elements[i] = elements[i + 1]; } elements[nextIndex] = null; return elementBeingRemoved; } We can combine these two cases:\n@Override public E remove(int index) { /* * Specification: if the index is out of bound, then throw * IndexOutOfBoundsException. */ if (index \u003c 0 || index \u003e= nextIndex) { throw new IndexOutOfBoundsException( \"index \" + index + \" is out of range\" ); } E elementBeingRemoved = (E) elements[index]; nextIndex--; for (int i = index; i \u003c nextIndex; i++) { elements[i] = elements[i + 1]; } elements[nextIndex] = null; return elementBeingRemoved; } We can also leverage the Data Locality property here by copying elements by blocks. We will use the same System.arraycopy method, where both our source and destination will be the same array. The JavaDoc of System.arraycopy says -\nIf the src and dest arguments refer to the same array object, then the copying is performed as if the components at positions srcPos through srcPos + length - 1 were first copied to a temporary array with length components and then the contents of the temporary array were copied into positions destPos through destPos + length - 1 of the destination array.\nTo understand how the copy within the same array will work, notice that we move the element at index index + 1 to index, index + 2 to index + 1, and then finally, the element at index nextIndex to index nextIndex - 1. This implies that we specify index + 1 as the source index when doing block copy, as that’s the first element we copy. We specify index as our destination index as that’s where the first element finally moves to. nextIndex - index will give us the number of elements that need to be copied, as shown by the image below:\nLet’s go ahead and refactor our method -\n@Override public E remove(int index) { /* * Specification: if the index is out of bound, then throw * IndexOutOfBoundsException. */ if (index \u003c 0 || index \u003e= nextIndex) { throw new IndexOutOfBoundsException( \"index \" + index + \" is out of range\" ); } E elementBeingRemoved = (E) elements[index]; nextIndex--; System.arraycopy(elements, index + 1, elements, index, nextIndex - index); elements[nextIndex] = null; return elementBeingRemoved; } We can also resize and reduce the array size similar to the add method above. I leave it up as a fun exercise for the reader.\nadd(index, element) Next method is add(index, element):\npublic void add(int index, E element) { /* * Specification: if the index is out of bound, then throw * IndexOutOfBoundsException. * * Notice the difference with the index check of the * `remove` method. */ if (index \u003c 0 || index \u003e nextIndex) { throw new IndexOutOfBoundsException( \"index \" + index + \" is out of range\" ); } /* * If the index == nextIndex, we can leverage the `add` * method to add the element at the end. */ if (index == nextIndex) { add(element); return; } } The initial version implements the relatively more straightforward cases - when the index is out of bounds and when we insert the element at the end of the list. To finish the implementation, we need to consider two additional cases - when we don’t have enough space and need to resize the array and where we have enough space.\nTo handle the first case, we will resize the array as we did for add. Once resized, we will copy the first index number of elements to this new array, add the element at the given index, and then copy the rest of the elements to the new array -\nTo handle the second case, we first shift all elements from the given index and then insert the new element at the index position. The code for both these cases are given below:\n@Override public void add(int index, E element) { /* * Specification: if the index is out of bound, * then throw IndexOutOfBoundsException. * * Notice the difference with the index check of the * `remove` method. */ if (index \u003c 0 || index \u003e nextIndex) { throw new IndexOutOfBoundsException( \"index \" + index + \" is out of range\" ); } /* * If the index == nextIndex, we can leverage the `add` * method to add the element at the end. */ if (index == nextIndex) { add(element); return; } if (nextIndex == elements.length) { Object[] copy = new Object[nextIndex * 2]; System.arraycopy(elements, 0, copy, 0, index); copy[index] = element; System.arraycopy(elements, index, copy, index + 1, nextIndex - index); elements = copy; } else { System.arraycopy(elements, index, elements, index + 1, nextIndex - index); elements[index] = element; } nextIndex++; } contains(element) This implementation is relatively straightforward. We do a linear scan through the elements array from left to right, checking for object equality to see if the given element exists in the array:\n@Override public boolean contains(Object element) { for (int i = 0; i \u003c nextIndex; i++) { if (Objects.equals(elements[i], element)) { return true; } } return false; } Or we can use streams:\n@Override public boolean contains(Object element) { return Arrays.stream(elements) .limit(size()) .anyMatch(existingElement -\u003e Objects.equals(existingElement, element)); } remove(element) We can leverage the existing remove(index) method to implement removal by element. To do that, we do a linear scan of our elements array, find the index of the element, and then call remove(index):\n@Override public boolean remove(Object element) { for (int i = 0; i \u003c nextIndex; i++) { if (Objects.equals(elements[i], element)) { remove(i); return true; } } return false; } iterator() We will implement a simplified version of the iterator, which will not check for concurrent modification and will not allow removal via the iterator.\nWe will write a custom Iterator, which will take a snapshot of our list’s size() and then continue iterating until we all elements have been returned:\nprivate class CustomArrayListIterator implements Iterator\u003cE\u003e { private final int size = CustomArrayList.this.size(); private int index = 0; @Override public boolean hasNext() { return index \u003c size; } @Override public E next() { return (E) elements[index++]; } } @Override public Iterator\u003cE\u003e iterator() { return new CustomArrayListIterator(); } When to use an array-backed list? Now that we have seen how an array-based list implementation works, when should we use them? And when should we avoid using them?\nAs a rule of thumb - I always prefer using ArrayList over other list implementations like LinkedList. In almost all cases, a linked list based-implementation will lose out to ArrayList in terms of performance. The performance boost from Data Locality combined with sequential memory block copy and Prefetching in L1 and/or L2 cache is hard to beat.\nThere is a particular scenario where LinkedList may perform better than ArrayList. When we constantly need to add and/or remove elements from the beginning of the list (or anywhere before the midpoint of the list) AND the list contains millions and millions of objects, then a LinkedList may provide better performance. Even then, I recommend performing a benchmark/load test to see if the ArrayList is the bottleneck.\nConclusion I hope you enjoyed reading the article. In future posts of the Unwinding the Abstraction series, I hope to demystify more tools and share the learnings with you all.\nThe sample implementation used in this article is available at Github.\nAcknowledgements Many thanks to Nur Bahar Yeasha for proofreading a draft version of this article and suggesting corrections and improvements.\n","wordCount":"2747","inLanguage":"en","datePublished":"2023-02-14T00:00:00+01:00","dateModified":"2023-02-14T00:00:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sayemahmed.com/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/"},"publisher":{"@type":"Organization","name":"Random Musings","logo":{"@type":"ImageObject","url":"https://www.sayemahmed.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.sayemahmed.com accesskey=h title="Random Musings (Alt + H)">Random Musings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.sayemahmed.com/about-me title="About Me"><span>About Me</span></a></li><li><a href=https://www.sayemahmed.com/index.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Unwinding the Abstraction - How does ArrayList in Java Work?</h1><div class=post-description>In this article, we will implement a custom ArrayList from scratch to understand how they work under the hood and what their best and worst use cases are.</div><div class=post-meta><span title='2023-02-14 00:00:00 +0100 CET'>February 14, 2023</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#creating-our-custom-arraylist-class aria-label="Creating our custom ArrayList class">Creating our custom ArrayList class</a></li><li><a href=#implementing-methods aria-label="Implementing methods">Implementing methods</a><ul><li><a href=#addelement aria-label=add(element)>add(element)</a></li><li><a href=#size aria-label=size()>size()</a></li><li><a href=#removeindex aria-label=remove(index)>remove(index)</a></li><li><a href=#addindex-element aria-label="add(index, element)">add(index, element)</a></li><li><a href=#containselement aria-label=contains(element)>contains(element)</a></li><li><a href=#removeelement aria-label=remove(element)>remove(element)</a></li><li><a href=#iterator aria-label=iterator()>iterator()</a></li></ul></li><li><a href=#when-to-use-an-array-backed-list aria-label="When to use an array-backed list?">When to use an array-backed list?</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#acknowledgements aria-label=Acknowledgements>Acknowledgements</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>One of my all-time favourite articles is <a href=https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/>The Law of Leaky Abstractions</a> by Joel Spolsky. In the article, Joel explains how non-trivial abstractions that make software development more manageable often break. And when they do, we need to understand how they truly work so we can fix them quickly.</p><p>This is the reason I value learning from first principles. Over the years, I have often applied this learning style to learn more about the tools I use regularly. In this blog post, I will share my learnings on <a href=(https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/ArrayList.html)>ArrayList</a>, an implementation of <a href=https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html>List</a>, by building a copy implementation from scratch.</p><p>Please note that we will not implement a production-grade implementation. Instead, we will focus on implementing the most commonly used list methods to get a feel for how they work and thus understand their use cases better.</p><h2 id=creating-our-custom-arraylist-class>Creating our custom <code>ArrayList</code> class<a hidden class=anchor aria-hidden=true href=#creating-our-custom-arraylist-class>#</a></h2><p>Let&rsquo;s declare the initial skeleton of the implementation -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CustomArrayList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=kd>implements</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>elements</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=nf>CustomArrayList</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[?];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><a href=https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html>The official doc</a> says that List implementations should support holding an arbitrary number of elements. However, we need to specify a size when creating the array. If we specify a large size, then we might waste memory. However, setting a shorter length puts a limitation on our capacity. So what do we do?</p><p>One way to get around this limitation is to create an array with a small capacity first and then resize it whenever we run out of space. Let&rsquo;s go ahead and declare a 1-element array -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>elements</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=mi>1</span><span class=o>];</span>
</span></span></code></pre></div><p>We could also consider passing the size during construction if we have a rough idea of how many elements we will store in this list. This would help us to initialise the array more efficiently as we would need less resizing. We could provide another constructor which would accept an <code>initialCapacity</code> as an argument and use it to initialise the array -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CustomArrayList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=kd>implements</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>elements</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=nf>CustomArrayList</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=nf>CustomArrayList</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>initialCapacity</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>This is why it&rsquo;s always better to instantiate <code>ArrayList</code> using capacity if we know it in advance. It avoids unnecessary resizing.</p><h2 id=implementing-methods>Implementing methods<a hidden class=anchor aria-hidden=true href=#implementing-methods>#</a></h2><h3 id=addelement><code>add(element)</code><a hidden class=anchor aria-hidden=true href=#addelement>#</a></h3><p>We will implement the <code>add</code> method first, which is supposed to append the specified element to the end of this list -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// If the insertion is successful, it should return true.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Otherwise, it should return false.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// This method should never replace any existing elements.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Before appending the given element in the array, we need to know the next available position. We will define a new instance field, <code>nextIndex</code>, pointing to the next free slot in the array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CustomArrayList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=kd>implements</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>elements</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Contains 0 by default
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>private</span> <span class=kt>int</span> <span class=n>nextIndex</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Once defined, let&rsquo;s continue our <code>add</code> implementation -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>nextIndex</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>How do we resize the array when it&rsquo;s full? One way to do it is to create a new array, copy all the elements from the existing array, and then point <code>elements</code> to this new array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>nextIndex</span> <span class=o>==</span> <span class=n>elements</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Object</span><span class=o>[]</span> <span class=n>copy</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>nextIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nextIndex</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>copy</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>      <span class=n>elements</span> <span class=o>=</span> <span class=n>copy</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nextIndex</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>What about performance? When we <code>add</code> a 2nd element to our list, we copy the existing element to the new array. On the 3rd <code>add</code>, the loop will copy two elements. Continuing like this, we can say that on N-th <code>add</code>, we will copy <code>(N - 1)</code> elements. To get the total number of copies required for the first <code>N</code> <code>add</code>, we sum them up = <code>1 + 2 + 3 + ... + (N - 1) = (N - 1) x N / 2</code>.</p><p><img loading=lazy src=image-showing-array-resize-by-1-during-add.jpg alt="Array resizing by extra 1 capacity"></p><p>Adding the first <code>N</code> elements thus has <a href=https://en.wikipedia.org/wiki/Amortized_analysis>an amortised time complexity</a> of <code>O(N^2)</code>. This means that if we double the size of the elements being added, the total time needed will increase 4-fold. Can we do better?</p><p>Thankfully, we can. Instead of increasing the capacity by one, we will double it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>nextIndex</span> <span class=o>==</span> <span class=n>elements</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Object</span><span class=o>[]</span> <span class=n>copy</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>nextIndex</span> <span class=o>*</span> <span class=mi>2</span><span class=o>];</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nextIndex</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>copy</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>      <span class=n>elements</span> <span class=o>=</span> <span class=n>copy</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nextIndex</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>The amortised time complexity will now reduce to <code>O(N)</code>. Like before, the 2nd <code>add</code> will copy one element. But before the 3rd <code>add</code>, our implementation will double the size of the <code>elements</code> array, so the 4th <code>add</code> won&rsquo;t need to resize it again. The 5th <code>add</code> will again double the capacity and copy the existing 4 elements, but then the 6th, 7th, and 8th calls won&rsquo;t trigger a resize.</p><p><img loading=lazy src=image-showing-array-resize-by-doubling-during-add.jpg alt="Array resizing by extra 1 capacity"></p><p>We can improve the actual performance even further by acknowledging a property of arrays called Data Locality. Data Locality guarantees that array elements are always stored in consecutive memory locations.</p><p><img loading=lazy src=data-locality.jpg alt="Data Locality"></p><p>So rather than copying one element at a time, how about we copy blocks of memory instead? The <a href=https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/System.html>System</a> class has one such method, <a href=https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/System.html#arraycopy(java.lang.Object,int,java.lang.Object,int,int)>arraycopy</a>, which we can use for this purpose:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>nextIndex</span> <span class=o>==</span> <span class=n>elements</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Object</span><span class=o>[]</span> <span class=n>copy</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>nextIndex</span> <span class=o>*</span> <span class=mi>2</span><span class=o>];</span>
</span></span><span class=line><span class=cl>      <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>copy</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>nextIndex</span><span class=o>);</span>
</span></span><span class=line><span class=cl>      <span class=n>elements</span> <span class=o>=</span> <span class=n>copy</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nextIndex</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>We can better understand the performance boost by looking at approximate latency numbers <a href=https://colin-scott.github.io/personal_website/research/interactive_latency.html>from this chart</a>. As we can see, reading ~1MB of sequential data from main memory takes about ~1 microsecond. On the other hand, a random main memory reference takes about 100 nanoseconds. This shows that reading 10 elements from random memory locations would take roughly the same time as reading 1MB of sequential data.</p><p>Moreover, the CPU will likely have an L1 (and maybe L2) cache. When the OS fetches an array element from the main memory to the L1 cache, it&rsquo;s likely to <a href=https://en.wikipedia.org/wiki/Cache_prefetching>prefetch and store</a> the elements at the following indexes, improving the performance even further.</p><p><img loading=lazy src=caching-architecture.jpg alt="Data Locality"></p><p>Notice how we make a conscious trade-off between memory and running time when we double the array. This is fine if memory is available and cheap, which is <em>usually</em> the case. If not, we need a different strategy (i.e., increase the length by 25% or 50%).</p><h3 id=size><code>size()</code><a hidden class=anchor aria-hidden=true href=#size>#</a></h3><p>Next, we will implement the <code>size</code> method, which returns the number of elements in the list. The way we used <code>nextIndex</code> in our <code>add</code> method, it will always be equal to the size of the list:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>int</span> <span class=nf>size</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>nextIndex</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=removeindex><code>remove(index)</code><a hidden class=anchor aria-hidden=true href=#removeindex>#</a></h3><p>Next up, the <code>remove</code> method -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;=</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>If <code>index</code> is the last element in the <code>elements</code> array, we could decrement <code>nextIndex</code> by one so that the next insertion will overwrite the element at index <code>nextIndex - 1</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;=</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>==</span> <span class=n>nextIndex</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Unfortunately, this implementation suffers from a memory leak. Let me explain why.</p><p>Suppose we have a list object with 10,000 elements and would like to remove each element one by one from the end without adding any new ones. In that case, <code>nextIndex</code> will keep decreasing, but the references to all these removed objects will still be in the array, preventing garbage collection.</p><p><img loading=lazy src=memory-leak.jpg alt="Memory leak due to stale references"></p><p>To prevent memory leak, we need to explicitly clear the reference by setting it to <code>null</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;=</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>==</span> <span class=n>nextIndex</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>    <span class=n>E</span> <span class=n>elementBeingRemoved</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>elementBeingRemoved</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>To remove elements from any other position in the array, we can shift all elements starting from <code>index</code> one position to the left and then decrement <code>nextIndex</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;=</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>==</span> <span class=n>nextIndex</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>    <span class=n>E</span> <span class=n>elementBeingRemoved</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>elementBeingRemoved</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>E</span> <span class=n>elementBeingRemoved</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>index</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nextIndex</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>elements</span><span class=o>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>elementBeingRemoved</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>We can combine these two cases:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;=</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>E</span> <span class=n>elementBeingRemoved</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>index</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nextIndex</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>elements</span><span class=o>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>elementBeingRemoved</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>We can also leverage the Data Locality property here by copying elements by blocks. We will use the same <code>System.arraycopy</code> method, where both our source and destination will be the same array. The JavaDoc of <a href=https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/System.html#arraycopy(java.lang.Object,int,java.lang.Object,int,int)>System.arraycopy</a> says -</p><blockquote><p>If the src and dest arguments refer to the same array object, then the copying is performed as if the components at positions <code>srcPos</code> through <code>srcPos + length - 1</code> were first copied to a temporary array with <code>length</code> components and then the contents of the temporary array were copied into positions <code>destPos</code> through <code>destPos + length - 1</code> of the destination array.</p></blockquote><p>To understand how the copy within the same array will work, notice that we move the element at index <code>index + 1</code> to <code>index</code>, <code>index + 2</code> to <code>index + 1</code>, and then finally, the element at index <code>nextIndex</code> to index <code>nextIndex - 1</code>. This implies that we specify <code>index + 1</code> as the source index when doing block copy, as that&rsquo;s the first element we copy. We specify <code>index</code> as our destination index as that&rsquo;s where the first element finally moves to. <code>nextIndex - index</code> will give us the number of elements that need to be copied, as shown by the image below:</p><p><img loading=lazy src=shifting-element-while-remove.jpg alt="Element shift during remove"></p><p>Let&rsquo;s go ahead and refactor our method -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;=</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>E</span> <span class=n>elementBeingRemoved</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>  <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span>
</span></span><span class=line><span class=cl>      <span class=n>elements</span><span class=o>,</span> <span class=n>index</span><span class=o>,</span> <span class=n>nextIndex</span> <span class=o>-</span> <span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>elementBeingRemoved</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>We can also resize and reduce the array size similar to the <code>add</code> method above. I leave it up as a fun exercise for the reader.</p><h3 id=addindex-element><code>add(index, element)</code><a hidden class=anchor aria-hidden=true href=#addindex-element>#</a></h3><p>Next method is <code>add(index, element)</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>add</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>,</span> <span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * Notice the difference with the index check of the
</span></span></span><span class=line><span class=cl><span class=cm>   * `remove` method.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * If the index == nextIndex, we can leverage the `add`
</span></span></span><span class=line><span class=cl><span class=cm>   * method to add the element at the end.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>==</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>add</span><span class=o>(</span><span class=n>element</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>The initial version implements the relatively more straightforward cases - when the index is out of bounds and when we insert the element at the end of the list. To finish the implementation, we need to consider two additional cases - when we don&rsquo;t have enough space and need to resize the array and where we have enough space.</p><p>To handle the first case, we will resize the array as we did for <code>add</code>. Once resized, we will copy the first <code>index</code> number of elements to this new array, add the element at the given <code>index</code>, and then copy the rest of the elements to the new array -</p><p><img loading=lazy src=shift-during-add.jpg alt="Element shift during add"></p><p>To handle the second case, we first shift all elements from the given <code>index</code> and then insert the new element at the <code>index</code> position. The code for both these cases are given below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>add</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>,</span> <span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound,
</span></span></span><span class=line><span class=cl><span class=cm>   * then throw IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * Notice the difference with the index check of the
</span></span></span><span class=line><span class=cl><span class=cm>   * `remove` method.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * If the index == nextIndex, we can leverage the `add`
</span></span></span><span class=line><span class=cl><span class=cm>   * method to add the element at the end.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>==</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>add</span><span class=o>(</span><span class=n>element</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>nextIndex</span> <span class=o>==</span> <span class=n>elements</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Object</span><span class=o>[]</span> <span class=n>copy</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>nextIndex</span> <span class=o>*</span> <span class=mi>2</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>copy</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>copy</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>index</span><span class=o>,</span>
</span></span><span class=line><span class=cl>        <span class=n>copy</span><span class=o>,</span> <span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span> <span class=n>nextIndex</span> <span class=o>-</span> <span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span> <span class=o>=</span> <span class=n>copy</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>index</span><span class=o>,</span>
</span></span><span class=line><span class=cl>        <span class=n>elements</span><span class=o>,</span> <span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span> <span class=n>nextIndex</span> <span class=o>-</span> <span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>nextIndex</span><span class=o>++;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=containselement><code>contains(element)</code><a hidden class=anchor aria-hidden=true href=#containselement>#</a></h3><p>This implementation is relatively straightforward. We do a linear scan through the <code>elements</code> array from left to right, checking for object equality to see if the given element exists in the array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>contains</span><span class=o>(</span><span class=n>Object</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nextIndex</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>Objects</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>],</span> <span class=n>element</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Or we can use streams:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>contains</span><span class=o>(</span><span class=n>Object</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>elements</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>limit</span><span class=o>(</span><span class=n>size</span><span class=o>())</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>anyMatch</span><span class=o>(</span><span class=n>existingElement</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=n>Objects</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>existingElement</span><span class=o>,</span> <span class=n>element</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=removeelement><code>remove(element)</code><a hidden class=anchor aria-hidden=true href=#removeelement>#</a></h3><p>We can leverage the existing <code>remove(index)</code> method to implement removal by element. To do that, we do a linear scan of our <code>elements</code> array, find the index of the element, and then call <code>remove(index)</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>remove</span><span class=o>(</span><span class=n>Object</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nextIndex</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>Objects</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>],</span> <span class=n>element</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>remove</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=iterator><code>iterator()</code><a hidden class=anchor aria-hidden=true href=#iterator>#</a></h3><p>We will implement a simplified version of the <code>iterator</code>, which will not check for concurrent modification and will not allow removal via the iterator.</p><p>We will write a custom <a href=https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Iterator.html>Iterator</a>, which will take a snapshot of our list&rsquo;s <code>size()</code> and then continue iterating until we all elements have been returned:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>class</span> <span class=nc>CustomArrayListIterator</span> <span class=kd>implements</span> <span class=n>Iterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>CustomArrayList</span><span class=o>.</span><span class=na>this</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>hasNext</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>index</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=n>E</span> <span class=nf>next</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>++];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>Iterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=nf>iterator</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>new</span> <span class=n>CustomArrayListIterator</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=when-to-use-an-array-backed-list>When to use an array-backed list?<a hidden class=anchor aria-hidden=true href=#when-to-use-an-array-backed-list>#</a></h2><p>Now that we have seen how an array-based list implementation works, when should we use them? And when should we avoid using them?</p><blockquote><p>As a rule of thumb - I always prefer using <code>ArrayList</code> over other list implementations like <code>LinkedList</code>. In almost all cases, a linked list based-implementation will lose out to ArrayList in terms of performance. The performance boost from Data Locality combined with sequential memory block copy and Prefetching in L1 and/or L2 cache is hard to beat.</p></blockquote><p>There is a particular scenario where <code>LinkedList</code> <em>may</em> perform better than <code>ArrayList</code>. When we constantly need to add and/or remove elements from the beginning of the list (or anywhere before the midpoint of the list) <em>AND</em> the list contains millions and millions of objects, then a <code>LinkedList</code> <em>may</em> provide better performance. Even then, I recommend performing a benchmark/load test to see <em>if</em> the <code>ArrayList</code> is the bottleneck.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I hope you enjoyed reading the article. In future posts of the <code>Unwinding the Abstraction</code> series, I hope to demystify more tools and share the learnings with you all.</p><p>The sample implementation used in this article is available <a href=https://github.com/sayembd/java-examples/blob/main/java-core/src/main/java/com/sayemahmed/example/collection/CustomArrayList.java>at Github</a>.</p><h2 id=acknowledgements>Acknowledgements<a hidden class=anchor aria-hidden=true href=#acknowledgements>#</a></h2><p>Many thanks to <a href=https://www.linkedin.com/in/yeasha/>Nur Bahar Yeasha</a> for proofreading a draft version of this article and suggesting corrections and improvements.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.sayemahmed.com/posts/my-first-brush-with-go/><span class=title>« Prev</span><br><span>My First Brush With Go</span></a>
<a class=next href=https://www.sayemahmed.com/posts/debugging-friendly-logging-patterns/><span class=title>Next »</span><br><span>On-call-friendly Java Logging Patterns</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Unwinding the Abstraction - How does ArrayList in Java Work? on x" href="https://x.com/intent/tweet/?text=Unwinding%20the%20Abstraction%20-%20How%20does%20ArrayList%20in%20Java%20Work%3f&amp;url=https%3a%2f%2fwww.sayemahmed.com%2fposts%2funwinding-the-abstraction-how-does-arraylist-in-java-work%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Unwinding the Abstraction - How does ArrayList in Java Work? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.sayemahmed.com%2fposts%2funwinding-the-abstraction-how-does-arraylist-in-java-work%2f&amp;title=Unwinding%20the%20Abstraction%20-%20How%20does%20ArrayList%20in%20Java%20Work%3f&amp;summary=Unwinding%20the%20Abstraction%20-%20How%20does%20ArrayList%20in%20Java%20Work%3f&amp;source=https%3a%2f%2fwww.sayemahmed.com%2fposts%2funwinding-the-abstraction-how-does-arraylist-in-java-work%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Unwinding the Abstraction - How does ArrayList in Java Work? on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.sayemahmed.com%2fposts%2funwinding-the-abstraction-how-does-arraylist-in-java-work%2f&title=Unwinding%20the%20Abstraction%20-%20How%20does%20ArrayList%20in%20Java%20Work%3f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Unwinding the Abstraction - How does ArrayList in Java Work? on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.sayemahmed.com%2fposts%2funwinding-the-abstraction-how-does-arraylist-in-java-work%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Unwinding the Abstraction - How does ArrayList in Java Work? on whatsapp" href="https://api.whatsapp.com/send?text=Unwinding%20the%20Abstraction%20-%20How%20does%20ArrayList%20in%20Java%20Work%3f%20-%20https%3a%2f%2fwww.sayemahmed.com%2fposts%2funwinding-the-abstraction-how-does-arraylist-in-java-work%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Unwinding the Abstraction - How does ArrayList in Java Work? on telegram" href="https://telegram.me/share/url?text=Unwinding%20the%20Abstraction%20-%20How%20does%20ArrayList%20in%20Java%20Work%3f&amp;url=https%3a%2f%2fwww.sayemahmed.com%2fposts%2funwinding-the-abstraction-how-does-arraylist-in-java-work%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Unwinding the Abstraction - How does ArrayList in Java Work? on ycombinator" href="https://news.ycombinator.com/submitlink?t=Unwinding%20the%20Abstraction%20-%20How%20does%20ArrayList%20in%20Java%20Work%3f&u=https%3a%2f%2fwww.sayemahmed.com%2fposts%2funwinding-the-abstraction-how-does-arraylist-in-java-work%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.sayemahmed.com>Random Musings</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>