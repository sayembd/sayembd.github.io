<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unwinding the Abstraction - How does ArrayList in Java Work? | Random Musings</title><meta name=keywords content><meta name=description content="In this article, we will implement a custom ArrayList from scratch to understand how they work under the hood and what their best and worst use cases are."><meta name=author content><link rel=canonical href=https://www.sayemahmed.com/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/><link crossorigin=anonymous href=/assets/css/stylesheet.min.5fc7093e58e5038c03e70b417ab8f50482ebc513e1b1e74b0e42a004bc7ce7ed.css integrity="sha256-X8cJPljlA4wD5wtBerj1BILrxRPhsedLDkKgBLx85+0=" rel="preload stylesheet" as=style><link rel=icon href=https://www.sayemahmed.com/favicon.ico><link rel=apple-touch-icon href=https://www.sayemahmed.com/apple-touch-icon.png><meta name=twitter:title content="Unwinding the Abstraction - How does ArrayList in Java Work? | Random Musings"><meta name=twitter:description content="In this article, we will implement a custom ArrayList from scratch to understand how they work under the hood and what their best and worst use cases are."><meta name=twitter:site content="@novoreorx"><meta name=twitter:creator content="@novoreorx"><meta property="og:title" content="Unwinding the Abstraction - How does ArrayList in Java Work? | Random Musings"><meta property="og:description" content="In this article, we will implement a custom ArrayList from scratch to understand how they work under the hood and what their best and worst use cases are."><meta property="og:type" content="article"><meta property="og:url" content="https://www.sayemahmed.com/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-14T00:00:00+01:00"><meta property="article:modified_time" content="2023-02-14T00:00:00+01:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.sayemahmed.com/posts/"},{"@type":"ListItem","position":3,"name":"Unwinding the Abstraction - How does ArrayList in Java Work?","item":"https://www.sayemahmed.com/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unwinding the Abstraction - How does ArrayList in Java Work? | Random Musings","name":"Unwinding the Abstraction - How does ArrayList in Java Work?","description":"In this article, we will implement a custom ArrayList from scratch to understand how they work under the hood and what their best and worst use cases are.","keywords":[],"wordCount":"2747","inLanguage":"en","datePublished":"2023-02-14T00:00:00+01:00","dateModified":"2023-02-14T00:00:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sayemahmed.com/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/"},"publisher":{"@type":"Organization","name":"Random Musings","logo":{"@type":"ImageObject","url":"https://www.sayemahmed.com/favicon.ico"}}}</script><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript></head><body id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="light",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://www.sayemahmed.com accesskey=h title="Random Musings (Alt + H)">Random Musings</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.sayemahmed.com/about-me/ title="About Me">About Me</a></li><li><a href=https://www.sayemahmed.com/index.xml/ title=RSS>RSS</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><h1 class=post-title>Unwinding the Abstraction - How does ArrayList in Java Work?</h1><div class=post-description>In this article, we will implement a custom ArrayList from scratch to understand how they work under the hood and what their best and worst use cases are.</div><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>February 14, 2023</span></span></div></header><div class="toc side left"><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#creating-our-custom-arraylist-class aria-label="Creating our custom ArrayList class">Creating our custom <code>ArrayList</code> class</a></li><li><a href=#implementing-methods aria-label="Implementing methods">Implementing methods</a><ul><li><a href=#addelement aria-label=add(element)><code>add(element)</code></a></li><li><a href=#size aria-label=size()><code>size()</code></a></li><li><a href=#removeindex aria-label=remove(index)><code>remove(index)</code></a></li><li><a href=#addindex-element aria-label="add(index, element)"><code>add(index, element)</code></a></li><li><a href=#containselement aria-label=contains(element)><code>contains(element)</code></a></li><li><a href=#removeelement aria-label=remove(element)><code>remove(element)</code></a></li><li><a href=#iterator aria-label=iterator()><code>iterator()</code></a></li></ul></li><li><a href=#when-to-use-an-array-backed-list aria-label="When to use an array-backed list?">When to use an array-backed list?</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#acknowledgements aria-label=Acknowledgements>Acknowledgements</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>¶</a></h2><p>One of my all-time favourite articles is <a href=https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/>The Law of Leaky Abstractions</a> by Joel Spolsky. In the article, Joel explains how non-trivial abstractions that make software development more manageable often break. And when they do, we need to understand how they truly work so we can fix them quickly.</p><p>This is the reason I value learning from first principles. Over the years, I have often applied this learning style to learn more about the tools I use regularly. In this blog post, I will share my learnings on <a href=(https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/ArrayList.html)>ArrayList</a>, an implementation of <a href=https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html>List</a>, by building a copy implementation from scratch.</p><p>Please note that we will not implement a production-grade implementation. Instead, we will focus on implementing the most commonly used list methods to get a feel for how they work and thus understand their use cases better.</p><h2 id=creating-our-custom-arraylist-class>Creating our custom <code>ArrayList</code> class<a hidden class=anchor aria-hidden=true href=#creating-our-custom-arraylist-class>¶</a></h2><p>Let&rsquo;s declare the initial skeleton of the implementation -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CustomArrayList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=kd>implements</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>elements</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=nf>CustomArrayList</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[?];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><a href=https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/List.html>The official doc</a> says that List implementations should support holding an arbitrary number of elements. However, we need to specify a size when creating the array. If we specify a large size, then we might waste memory. However, setting a shorter length puts a limitation on our capacity. So what do we do?</p><p>One way to get around this limitation is to create an array with a small capacity first and then resize it whenever we run out of space. Let&rsquo;s go ahead and declare a 1-element array -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>elements</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=mi>1</span><span class=o>];</span>
</span></span></code></pre></div><p>We could also consider passing the size during construction if we have a rough idea of how many elements we will store in this list. This would help us to initialise the array more efficiently as we would need less resizing. We could provide another constructor which would accept an <code>initialCapacity</code> as an argument and use it to initialise the array -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CustomArrayList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=kd>implements</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>elements</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=nf>CustomArrayList</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>(</span><span class=mi>1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=nf>CustomArrayList</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>initialCapacity</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>This is why it&rsquo;s always better to instantiate <code>ArrayList</code> using capacity if we know it in advance. It avoids unnecessary resizing.</p><h2 id=implementing-methods>Implementing methods<a hidden class=anchor aria-hidden=true href=#implementing-methods>¶</a></h2><h3 id=addelement><code>add(element)</code><a hidden class=anchor aria-hidden=true href=#addelement>¶</a></h3><p>We will implement the <code>add</code> method first, which is supposed to append the specified element to the end of this list -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// If the insertion is successful, it should return true.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// Otherwise, it should return false.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// This method should never replace any existing elements.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Before appending the given element in the array, we need to know the next available position. We will define a new instance field, <code>nextIndex</code>, pointing to the next free slot in the array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CustomArrayList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=kd>implements</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>Object</span><span class=o>[]</span> <span class=n>elements</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Contains 0 by default
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>private</span> <span class=kt>int</span> <span class=n>nextIndex</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Once defined, let&rsquo;s continue our <code>add</code> implementation -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>nextIndex</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>How do we resize the array when it&rsquo;s full? One way to do it is to create a new array, copy all the elements from the existing array, and then point <code>elements</code> to this new array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>nextIndex</span> <span class=o>==</span> <span class=n>elements</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Object</span><span class=o>[]</span> <span class=n>copy</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>nextIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nextIndex</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>copy</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>      <span class=n>elements</span> <span class=o>=</span> <span class=n>copy</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nextIndex</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>What about performance? When we <code>add</code> a 2nd element to our list, we copy the existing element to the new array. On the 3rd <code>add</code>, the loop will copy two elements. Continuing like this, we can say that on N-th <code>add</code>, we will copy <code>(N - 1)</code> elements. To get the total number of copies required for the first <code>N</code> <code>add</code>, we sum them up = <code>1 + 2 + 3 + ... + (N - 1) = (N - 1) x N / 2</code>.</p><p><img loading=lazy src=/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/image-showing-array-resize-by-1-during-add.jpg type alt="Array resizing by extra 1 capacity"></p><p>Adding the first <code>N</code> elements thus has <a href=https://en.wikipedia.org/wiki/Amortized_analysis>an amortised time complexity</a> of <code>O(N^2)</code>. This means that if we double the size of the elements being added, the total time needed will increase 4-fold. Can we do better?</p><p>Thankfully, we can. Instead of increasing the capacity by one, we will double it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>nextIndex</span> <span class=o>==</span> <span class=n>elements</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Object</span><span class=o>[]</span> <span class=n>copy</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>nextIndex</span> <span class=o>*</span> <span class=mi>2</span><span class=o>];</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nextIndex</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>copy</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>      <span class=n>elements</span> <span class=o>=</span> <span class=n>copy</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nextIndex</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>The amortised time complexity will now reduce to <code>O(N)</code>. Like before, the 2nd <code>add</code> will copy one element. But before the 3rd <code>add</code>, our implementation will double the size of the <code>elements</code> array, so the 4th <code>add</code> won&rsquo;t need to resize it again. The 5th <code>add</code> will again double the capacity and copy the existing 4 elements, but then the 6th, 7th, and 8th calls won&rsquo;t trigger a resize.</p><p><img loading=lazy src=/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/image-showing-array-resize-by-doubling-during-add.jpg type alt="Array resizing by extra 1 capacity"></p><p>We can improve the actual performance even further by acknowledging a property of arrays called Data Locality. Data Locality guarantees that array elements are always stored in consecutive memory locations.</p><p><img loading=lazy src=/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/data-locality.jpg type alt="Data Locality"></p><p>So rather than copying one element at a time, how about we copy blocks of memory instead? The <a href=https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/System.html>System</a> class has one such method, <a href=https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/System.html#arraycopy(java.lang.Object,int,java.lang.Object,int,int)>arraycopy</a>, which we can use for this purpose:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>add</span><span class=o>(</span><span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>nextIndex</span> <span class=o>==</span> <span class=n>elements</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Object</span><span class=o>[]</span> <span class=n>copy</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>nextIndex</span> <span class=o>*</span> <span class=mi>2</span><span class=o>];</span>
</span></span><span class=line><span class=cl>      <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>copy</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>nextIndex</span><span class=o>);</span>
</span></span><span class=line><span class=cl>      <span class=n>elements</span> <span class=o>=</span> <span class=n>copy</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nextIndex</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>We can better understand the performance boost by looking at approximate latency numbers <a href=https://colin-scott.github.io/personal_website/research/interactive_latency.html>from this chart</a>. As we can see, reading ~1MB of sequential data from main memory takes about ~1 microsecond. On the other hand, a random main memory reference takes about 100 nanoseconds. This shows that reading 10 elements from random memory locations would take roughly the same time as reading 1MB of sequential data.</p><p>Moreover, the CPU will likely have an L1 (and maybe L2) cache. When the OS fetches an array element from the main memory to the L1 cache, it&rsquo;s likely to <a href=https://en.wikipedia.org/wiki/Cache_prefetching>prefetch and store</a> the elements at the following indexes, improving the performance even further.</p><p><img loading=lazy src=/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/caching-architecture.jpg type alt="Data Locality"></p><p>Notice how we make a conscious trade-off between memory and running time when we double the array. This is fine if memory is available and cheap, which is <em>usually</em> the case. If not, we need a different strategy (i.e., increase the length by 25% or 50%).</p><h3 id=size><code>size()</code><a hidden class=anchor aria-hidden=true href=#size>¶</a></h3><p>Next, we will implement the <code>size</code> method, which returns the number of elements in the list. The way we used <code>nextIndex</code> in our <code>add</code> method, it will always be equal to the size of the list:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>int</span> <span class=nf>size</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>nextIndex</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=removeindex><code>remove(index)</code><a hidden class=anchor aria-hidden=true href=#removeindex>¶</a></h3><p>Next up, the <code>remove</code> method -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;=</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>If <code>index</code> is the last element in the <code>elements</code> array, we could decrement <code>nextIndex</code> by one so that the next insertion will overwrite the element at index <code>nextIndex - 1</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;=</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>==</span> <span class=n>nextIndex</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Unfortunately, this implementation suffers from a memory leak. Let me explain why.</p><p>Suppose we have a list object with 10,000 elements and would like to remove each element one by one from the end without adding any new ones. In that case, <code>nextIndex</code> will keep decreasing, but the references to all these removed objects will still be in the array, preventing garbage collection.</p><p><img loading=lazy src=/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/memory-leak.jpg type alt="Memory leak due to stale references"></p><p>To prevent memory leak, we need to explicitly clear the reference by setting it to <code>null</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;=</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>==</span> <span class=n>nextIndex</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>    <span class=n>E</span> <span class=n>elementBeingRemoved</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>elementBeingRemoved</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>To remove elements from any other position in the array, we can shift all elements starting from <code>index</code> one position to the left and then decrement <code>nextIndex</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;=</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>==</span> <span class=n>nextIndex</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>    <span class=n>E</span> <span class=n>elementBeingRemoved</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>elementBeingRemoved</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>E</span> <span class=n>elementBeingRemoved</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>index</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nextIndex</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>elements</span><span class=o>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>elementBeingRemoved</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>We can combine these two cases:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;=</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>E</span> <span class=n>elementBeingRemoved</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>index</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nextIndex</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>elements</span><span class=o>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>elementBeingRemoved</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>We can also leverage the Data Locality property here by copying elements by blocks. We will use the same <code>System.arraycopy</code> method, where both our source and destination will be the same array. The JavaDoc of <a href=https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/System.html#arraycopy(java.lang.Object,int,java.lang.Object,int,int)>System.arraycopy</a> says -</p><blockquote><p>If the src and dest arguments refer to the same array object, then the copying is performed as if the components at positions <code>srcPos</code> through <code>srcPos + length - 1</code> were first copied to a temporary array with <code>length</code> components and then the contents of the temporary array were copied into positions <code>destPos</code> through <code>destPos + length - 1</code> of the destination array.</p></blockquote><p>To understand how the copy within the same array will work, notice that we move the element at index <code>index + 1</code> to <code>index</code>, <code>index + 2</code> to <code>index + 1</code>, and then finally, the element at index <code>nextIndex</code> to index <code>nextIndex - 1</code>. This implies that we specify <code>index + 1</code> as the source index when doing block copy, as that&rsquo;s the first element we copy. We specify <code>index</code> as our destination index as that&rsquo;s where the first element finally moves to. <code>nextIndex - index</code> will give us the number of elements that need to be copied, as shown by the image below:</p><p><img loading=lazy src=/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/shifting-element-while-remove.jpg type alt="Element shift during remove"></p><p>Let&rsquo;s go ahead and refactor our method -</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>E</span> <span class=nf>remove</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;=</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>E</span> <span class=n>elementBeingRemoved</span> <span class=o>=</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>];</span>
</span></span><span class=line><span class=cl>  <span class=n>nextIndex</span><span class=o>--;</span>
</span></span><span class=line><span class=cl>  <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span>
</span></span><span class=line><span class=cl>      <span class=n>elements</span><span class=o>,</span> <span class=n>index</span><span class=o>,</span> <span class=n>nextIndex</span> <span class=o>-</span> <span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=n>elements</span><span class=o>[</span><span class=n>nextIndex</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>elementBeingRemoved</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>We can also resize and reduce the array size similar to the <code>add</code> method above. I leave it up as a fun exercise for the reader.</p><h3 id=addindex-element><code>add(index, element)</code><a hidden class=anchor aria-hidden=true href=#addindex-element>¶</a></h3><p>Next method is <code>add(index, element)</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>add</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>,</span> <span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound, then throw
</span></span></span><span class=line><span class=cl><span class=cm>   * IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * Notice the difference with the index check of the
</span></span></span><span class=line><span class=cl><span class=cm>   * `remove` method.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * If the index == nextIndex, we can leverage the `add`
</span></span></span><span class=line><span class=cl><span class=cm>   * method to add the element at the end.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>==</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>add</span><span class=o>(</span><span class=n>element</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>The initial version implements the relatively more straightforward cases - when the index is out of bounds and when we insert the element at the end of the list. To finish the implementation, we need to consider two additional cases - when we don&rsquo;t have enough space and need to resize the array and where we have enough space.</p><p>To handle the first case, we will resize the array as we did for <code>add</code>. Once resized, we will copy the first <code>index</code> number of elements to this new array, add the element at the given <code>index</code>, and then copy the rest of the elements to the new array -</p><p><img loading=lazy src=/posts/unwinding-the-abstraction-how-does-arraylist-in-java-work/shift-during-add.jpg type alt="Element shift during add"></p><p>To handle the second case, we first shift all elements from the given <code>index</code> and then insert the new element at the <code>index</code> position. The code for both these cases are given below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>add</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>,</span> <span class=n>E</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * Specification: if the index is out of bound,
</span></span></span><span class=line><span class=cl><span class=cm>   * then throw IndexOutOfBoundsException.
</span></span></span><span class=line><span class=cl><span class=cm>   *
</span></span></span><span class=line><span class=cl><span class=cm>   * Notice the difference with the index check of the
</span></span></span><span class=line><span class=cl><span class=cm>   * `remove` method.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>index</span> <span class=o>&gt;</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfBoundsException</span><span class=o>(</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;index &#34;</span> <span class=o>+</span> <span class=n>index</span> <span class=o>+</span> <span class=s>&#34; is out of range&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   * If the index == nextIndex, we can leverage the `add`
</span></span></span><span class=line><span class=cl><span class=cm>   * method to add the element at the end.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>==</span> <span class=n>nextIndex</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>add</span><span class=o>(</span><span class=n>element</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=o>(</span><span class=n>nextIndex</span> <span class=o>==</span> <span class=n>elements</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Object</span><span class=o>[]</span> <span class=n>copy</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Object</span><span class=o>[</span><span class=n>nextIndex</span> <span class=o>*</span> <span class=mi>2</span><span class=o>];</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>copy</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>copy</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>index</span><span class=o>,</span>
</span></span><span class=line><span class=cl>        <span class=n>copy</span><span class=o>,</span> <span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span> <span class=n>nextIndex</span> <span class=o>-</span> <span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span> <span class=o>=</span> <span class=n>copy</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>System</span><span class=o>.</span><span class=na>arraycopy</span><span class=o>(</span><span class=n>elements</span><span class=o>,</span> <span class=n>index</span><span class=o>,</span>
</span></span><span class=line><span class=cl>        <span class=n>elements</span><span class=o>,</span> <span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span> <span class=n>nextIndex</span> <span class=o>-</span> <span class=n>index</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=n>nextIndex</span><span class=o>++;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=containselement><code>contains(element)</code><a hidden class=anchor aria-hidden=true href=#containselement>¶</a></h3><p>This implementation is relatively straightforward. We do a linear scan through the <code>elements</code> array from left to right, checking for object equality to see if the given element exists in the array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>contains</span><span class=o>(</span><span class=n>Object</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nextIndex</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>Objects</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>],</span> <span class=n>element</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Or we can use streams:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>contains</span><span class=o>(</span><span class=n>Object</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>elements</span><span class=o>)</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>limit</span><span class=o>(</span><span class=n>size</span><span class=o>())</span>
</span></span><span class=line><span class=cl>      <span class=o>.</span><span class=na>anyMatch</span><span class=o>(</span><span class=n>existingElement</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=n>Objects</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>existingElement</span><span class=o>,</span> <span class=n>element</span><span class=o>));</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=removeelement><code>remove(element)</code><a hidden class=anchor aria-hidden=true href=#removeelement>¶</a></h3><p>We can leverage the existing <code>remove(index)</code> method to implement removal by element. To do that, we do a linear scan of our <code>elements</code> array, find the index of the element, and then call <code>remove(index)</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>remove</span><span class=o>(</span><span class=n>Object</span> <span class=n>element</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nextIndex</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>Objects</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>],</span> <span class=n>element</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>remove</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=iterator><code>iterator()</code><a hidden class=anchor aria-hidden=true href=#iterator>¶</a></h3><p>We will implement a simplified version of the <code>iterator</code>, which will not check for concurrent modification and will not allow removal via the iterator.</p><p>We will write a custom <a href=https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Iterator.html>Iterator</a>, which will take a snapshot of our list&rsquo;s <code>size()</code> and then continue iterating until we all elements have been returned:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span> <span class=kd>class</span> <span class=nc>CustomArrayListIterator</span> <span class=kd>implements</span> <span class=n>Iterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>CustomArrayList</span><span class=o>.</span><span class=na>this</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>hasNext</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>index</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=n>E</span> <span class=nf>next</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>(</span><span class=n>E</span><span class=o>)</span> <span class=n>elements</span><span class=o>[</span><span class=n>index</span><span class=o>++];</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@Override</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>Iterator</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=nf>iterator</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>new</span> <span class=n>CustomArrayListIterator</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=when-to-use-an-array-backed-list>When to use an array-backed list?<a hidden class=anchor aria-hidden=true href=#when-to-use-an-array-backed-list>¶</a></h2><p>Now that we have seen how an array-based list implementation works, when should we use them? And when should we avoid using them?</p><blockquote><p>As a rule of thumb - I always prefer using <code>ArrayList</code> over other list implementations like <code>LinkedList</code>. In almost all cases, a linked list based-implementation will lose out to ArrayList in terms of performance. The performance boost from Data Locality combined with sequential memory block copy and Prefetching in L1 and/or L2 cache is hard to beat.</p></blockquote><p>There is a particular scenario where <code>LinkedList</code> <em>may</em> perform better than <code>ArrayList</code>. When we constantly need to add and/or remove elements from the beginning of the list (or anywhere before the midpoint of the list) <em>AND</em> the list contains millions and millions of objects, then a <code>LinkedList</code> <em>may</em> provide better performance. Even then, I recommend performing a benchmark/load test to see <em>if</em> the <code>ArrayList</code> is the bottleneck.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>¶</a></h2><p>I hope you enjoyed reading the article. In future posts of the <code>Unwinding the Abstraction</code> series, I hope to demystify more tools and share the learnings with you all.</p><p>The sample implementation used in this article is available <a href=https://github.com/sayembd/java-examples/blob/main/java-core/src/main/java/com/sayemahmed/example/collection/CustomArrayList.java>at Github</a>.</p><h2 id=acknowledgements>Acknowledgements<a hidden class=anchor aria-hidden=true href=#acknowledgements>¶</a></h2><p>Many thanks to <a href=https://www.linkedin.com/in/yeasha/>Nur Bahar Yeasha</a> for proofreading a draft version of this article and suggesting corrections and improvements.</p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://www.sayemahmed.com/posts/my-first-brush-with-go/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>My First Brush With Go</span></a>
<a class=next href=https://www.sayemahmed.com/posts/debugging-friendly-logging-patterns/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>On-call-friendly Java Logging Patterns</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.sayemahmed.com>Random Musings</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a></span>
<span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>